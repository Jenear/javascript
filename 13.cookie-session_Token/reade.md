# cookie session

## 什么是 cookie

```
HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，
它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

服务器端 ---> 浏览器端 ---> 服务器端

通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。
```

## Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

## 什么是 session

```
Session 代表着服务器和客户端一次会话的过程。
Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。
```

# cookie 和 session 有什么不同

- 作用范围不同： cookie 保存在客户端（浏览器） ； session 保存在服务器端
- 存取方式不同： cookie 只能保存 ASCII ； session 可以存储任意数据类型，一般情况下 session 中保存一些常用的信息，比如 userID 等
- 有效期不同： cookie 可设置为长时间保存，比如我们常使用的默认登录功能； session 一般失效时间较短：客户端关闭或者 session 超时都会失效
- 隐私策略不同：cookie 存在客户端，比较容易遭到不法获取； session 存储在客户端相对安全性高一些
- 存储大小不同： 单个 cookie 保存的数据不超过 4K；session 的存储远远高于 cookie；

# 为什么需要 cookie 和 session，他们有什么关联

### 主要是因为浏览者是没有状态的（HTTP 协议是无状态的）

```
说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。
```

## cookie 和 session 的配合：

```
 --------------------------------------        第一次发送请求                 ------------------------------------------
|                                     |  ------------------------------->    |（创建session）                            |
| 浏览器端                             |  <------------------------------     | 服务端                                    |
| （sessionID存入到cookie ）           |        返回sessionID                  |                                          |
|                                     |    第二次发送请求带cookie信息          | (第二次根据sessionID判断是哪个用户)         |
 -------------------------------------     ----------------------------->     -------------------------------------------
```

```
sessionID 可以认为是cookie和session的桥梁
```

# 如果浏览器禁止了 cookie，该如何实现通信

- 第一种方案：每次请求中的携带一个 sessionID 作为参数，也可以 post 方式也可以拼接到 url 后面（应该很危险？？）
- 第二种方案：Token 机制；token 的意思是"令牌"，服务器端生成一串字符串，作为客户端请求的一个标识，和 session-cookie 机制比较相似；安全度？？？？？

```
Token机制：
当用户第一次登陆后，服务器根据提交的用户信息生成一个Token，相应时将Token返回给客户端，以后客户端发送HTTP请求的时候把Token放到请求头（request header）里，无需再次登陆验证
```

#如何考虑分布式 session 问题？
在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

分布式 Session 一般会有以下几种解决方案：

- Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。

- Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。

- 共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。
  建议采用第三种方案。

# 如何解决跨域请求？

如何解决跨域请求？Jsonp 跨域的原理是什么？

说起跨域请求，必须要了解浏览器的同源策略，同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。

解决跨域请求的常用方法是：

通过代理来避免，比如使用 Nginx 在后端转发请求，避免了前端出现跨域的问题。

通过 Jsonp 跨域

其它跨域解决方案

重点谈一下 Jsonp 跨域原理。浏览器的同源策略把跨域请求都禁止了，但是页面中的 <script><img><iframe>标签是例外，不受同源策略限制。Jsonp 就是利用 <script> 标签跨域特性进行跨域数据访问。

JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。

JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求。
